{"ast":null,"code":"var _jsxFileName = \"C:\\\\gitHub\\\\retube-reactApp\\\\src\\\\components\\\\FullVideo\\\\FragmentControl.tsx\";\nimport * as React from \"react\";\nimport Slider, { createSliderWithTooltip } from \"rc-slider\";\nimport { FragmentControlStyled } from \"./styles\";\nimport { convertToTimeRange, convertToTime, formatTooltipRange } from \"../../utils\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SliderWithTooltip = createSliderWithTooltip(Slider.Range);\n_c = SliderWithTooltip;\nexport default class FragmentControl extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      changed: false,\n      value: {\n        max: 1,\n        min: 0\n      }\n    };\n    this.props = void 0;\n\n    this.handleChange = ([min, max]) => {\n      this.setState({\n        changed: true,\n        value: {\n          min,\n          max\n        }\n      });\n    };\n\n    this.handleChangeComplete = ([min, max]) => {\n      const {\n        provider: {\n          duration,\n          editActive\n        },\n        currentVideoClip: {\n          startTime,\n          endTime\n        },\n        editingValues\n      } = this.props;\n\n      if (editActive) {\n        editingValues({\n          editMax: convertToTime(max, duration),\n          editMin: convertToTime(min, duration)\n        });\n      } else {\n        min = convertToTimeRange(startTime, duration);\n        max = convertToTimeRange(endTime, duration);\n      }\n\n      this.setState({\n        changed: false,\n        value: {\n          min,\n          max\n        }\n      });\n    };\n  }\n\n  componentWillMount() {\n    const {\n      provider: {\n        duration\n      },\n      currentVideoClip: {\n        startTime,\n        endTime\n      }\n    } = this.props;\n    this.updateValue(startTime, endTime, duration);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const {\n      provider: {\n        duration\n      },\n      currentVideoClip: {\n        startTime,\n        endTime\n      }\n    } = this.props; // Changed video\n\n    if (nextProps.provider.duration && (nextProps.currentVideoClip.startTime !== startTime || nextProps.currentVideoClip.endTime !== endTime || nextProps.provider.duration !== duration)) {\n      const provider = nextProps.provider;\n      this.updateValue(nextProps.currentVideoClip.startTime, nextProps.currentVideoClip.endTime, provider.duration);\n    }\n  }\n\n  updateValue(startTime, endTime, duration) {\n    const {\n      editingValues\n    } = this.props;\n    const max = convertToTimeRange(endTime, duration);\n    const min = convertToTimeRange(startTime, duration);\n    this.setState({\n      value: {\n        max,\n        min\n      }\n    });\n    editingValues({\n      editMax: endTime,\n      editMin: startTime\n    });\n  }\n\n  get range() {\n    const {\n      provider: {\n        duration,\n        editActive\n      },\n      currentVideoClip: {\n        startTime,\n        endTime\n      }\n    } = this.props;\n    const {\n      changed,\n      value\n    } = this.state;\n\n    if (changed || editActive) {\n      return value;\n    }\n\n    return {\n      max: convertToTimeRange(endTime, duration),\n      min: convertToTimeRange(startTime, duration)\n    };\n  }\n\n  get value() {\n    const {\n      min,\n      max\n    } = this.range;\n    return [min, max];\n  }\n\n  render() {\n    const {\n      provider: {\n        duration,\n        editActive\n      }\n    } = this.props;\n    return /*#__PURE__*/_jsxDEV(FragmentControlStyled, {\n      editActive: editActive,\n      children: /*#__PURE__*/_jsxDEV(SliderWithTooltip, {\n        className: \"mark-fragment\",\n        max: 1000,\n        value: this.value,\n        onChange: this.handleChange,\n        onAfterChange: this.handleChangeComplete,\n        tipFormatter: formatTooltipRange(duration)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 138,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 137,\n      columnNumber: 7\n    }, this);\n  }\n\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"SliderWithTooltip\");","map":{"version":3,"sources":["C:/gitHub/retube-reactApp/src/components/FullVideo/FragmentControl.tsx"],"names":["React","Slider","createSliderWithTooltip","FragmentControlStyled","convertToTimeRange","convertToTime","formatTooltipRange","SliderWithTooltip","Range","FragmentControl","Component","state","changed","value","max","min","props","handleChange","setState","handleChangeComplete","provider","duration","editActive","currentVideoClip","startTime","endTime","editingValues","editMax","editMin","componentWillMount","updateValue","componentWillReceiveProps","nextProps","range","render"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport Video from \"./Video\";\n\nimport { IPropsChildrens as IPropsFromFullVideo } from \"./FullVideo\";\nimport Slider, { createSliderWithTooltip } from \"rc-slider\";\nimport { FragmentControlStyled } from \"./styles\";\nimport {\n  convertToTimeRange,\n  convertToTime,\n  formatTooltipRange,\n} from \"../../utils\";\n\ninterface IState {\n  changed: boolean;\n  value: { min: number; max: number };\n}\n\ninterface IProps extends IPropsFromFullVideo {\n  video: Video;\n}\n\nconst SliderWithTooltip = createSliderWithTooltip(Slider.Range);\n\nexport default class FragmentControl extends React.Component<IProps, IState> {\n  public state = {\n    changed: false,\n    value: {\n      max: 1,\n      min: 0,\n    },\n  };\n  props: {\n    provider: { duration: any };\n    currentVideoClip: { startTime: any; endTime: any };\n  };\n\n  public componentWillMount() {\n    const {\n      provider: { duration },\n      currentVideoClip: { startTime, endTime },\n    } = this.props;\n\n    this.updateValue(startTime, endTime, duration);\n  }\n\n  public componentWillReceiveProps(nextProps: IProps) {\n    const {\n      provider: { duration },\n      currentVideoClip: { startTime, endTime },\n    } = this.props;\n\n    // Changed video\n    if (\n      nextProps.provider.duration &&\n      (nextProps.currentVideoClip.startTime !== startTime ||\n        nextProps.currentVideoClip.endTime !== endTime ||\n        nextProps.provider.duration !== duration)\n    ) {\n      const provider = nextProps.provider;\n      this.updateValue(\n        nextProps.currentVideoClip.startTime,\n        nextProps.currentVideoClip.endTime,\n        provider.duration\n      );\n    }\n  }\n\n  public updateValue(startTime, endTime, duration) {\n    const { editingValues } = this.props;\n    const max = convertToTimeRange(endTime, duration);\n    const min = convertToTimeRange(startTime, duration);\n\n    this.setState({\n      value: {\n        max,\n        min,\n      },\n    });\n\n    editingValues({\n      editMax: endTime,\n      editMin: startTime,\n    });\n  }\n\n  get range() {\n    const {\n      provider: { duration, editActive },\n      currentVideoClip: { startTime, endTime },\n    } = this.props;\n\n    const { changed, value } = this.state;\n\n    if (changed || editActive) {\n      return value;\n    }\n\n    return {\n      max: convertToTimeRange(endTime, duration),\n      min: convertToTimeRange(startTime, duration),\n    };\n  }\n\n  get value() {\n    const { min, max } = this.range;\n    return [min, max];\n  }\n\n  public handleChange = ([min, max]: [number, number]) => {\n    this.setState({ changed: true, value: { min, max } });\n  };\n\n  public handleChangeComplete = ([min, max]: [number, number]) => {\n    const {\n      provider: { duration, editActive },\n      currentVideoClip: { startTime, endTime },\n      editingValues,\n    } = this.props;\n\n    if (editActive) {\n      editingValues({\n        editMax: convertToTime(max, duration),\n        editMin: convertToTime(min, duration),\n      });\n    } else {\n      min = convertToTimeRange(startTime, duration);\n      max = convertToTimeRange(endTime, duration);\n    }\n    this.setState({ changed: false, value: { min, max } });\n  };\n\n  public render() {\n    const {\n      provider: { duration, editActive },\n    } = this.props;\n    return (\n      <FragmentControlStyled editActive={editActive}>\n        <SliderWithTooltip\n          className=\"mark-fragment\"\n          max={1000}\n          value={this.value}\n          onChange={this.handleChange}\n          onAfterChange={this.handleChangeComplete}\n          tipFormatter={formatTooltipRange(duration)}\n        />\n      </FragmentControlStyled>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}